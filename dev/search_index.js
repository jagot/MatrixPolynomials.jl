var documenterSearchIndex = {"docs":
[{"location":"divided_differences/#Divided-differences-1","page":"Divided differences","title":"Divided differences","text":"","category":"section"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"The divided differences of a function f with respect to a set of interpolation points zeta_i is defined as (McCurdy 1984)","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"beginequation\nlabeleqndiv-diff-def\ndivdiff(zeta_ij)f defd\nfrac12piim\noint\ndiffz\nfracf(z)(z-zeta_i)(z-zeta_i+1)(z-zeta_j)\nendequation","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"where the integral is taken along a simple contour encircling the poles once. A common approach to evaluate the divided differences of f, and an alternative definition, is the recursive scheme","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"beginequation\nlabeleqndiv-diff-recursive\ntagrefeqndiv-diff-def*\ndivdiff(zeta_ijz)f defd\nfracdivdiff(zeta_ij-1z)f-divdiff(zeta_ij)fz - zeta_j quad\ndivdiff(zeta_iz)f defd\nfracdivdiff(z)f-divdiff(zeta_i)fz - zeta_i quad\ndivdiff(z)f defd f(z)\nendequation","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"which, however, is prone to catastrophic cancellation for very small abszeta_i-zeta_j. This can be partially alleviated by employing BigFloats, but that will only postpone the breakdown, albeit with ~40 orders of magnitude, which might be enough for practical purposes (but much slower).","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"For specific choices of f, efficient and accurate algorithms can be devised. MatrixPolynomials.φₖ_ts_div_diff is based upon the fact the divided differences in a third way can be computed as (McCurdy 1984, Opitz 1964)","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"beginequation\nlabeleqndiv-diff-mat-fun\ntagrefeqndiv-diff-def\ndivdiff(zeta_ij)f defd\nvece_1^top\nf(matZ_ij)\nendequation","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"i.e. the first row of the function f applied to the matrix","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"beginequation\nmatZ_ijdefd\nbmat\nzeta_i1\nzeta_i+11\nddotsddots\nddots1\nzeta_j\nendequation","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"The right-eigenvectors are given by (Opitz 1964)","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"beginequation\nlabeleqndiv-diff-mat-right-eigen\nmatQ_zeta = q_ik quad\nq_ik =\nbegincases\nprod_j=i^k-1 (zeta_k - zeta_j)^-1  i  k\n1  i = k\n0  textrmelse\nendcases\nendequation","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"and similarly, the left-eigenvectors are given by","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"beginequation\nlabeleqndiv-diff-mat-left-eigen\ntagrefeqndiv-diff-mat-right-eigen*\nmatQ_zeta^-1 = conjq_ik quad\nconjq_ik =\nbegincases\nprod_j=i+1^k (zeta_i - zeta_j)^-1  i  k\n1  i = k\n0  textrmelse\nendcases\nendequation","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"such that","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"beginequation\ndivdiff(zeta_ij)f=\nmatQ_zetamatF_zetamatQ_zeta^-1quad\nmatF_zeta defd bmatf(zeta_i)f(zeta_i+1)ddotsf(zeta_j)\nendequation","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"However, straight evaluation of (refeqndiv-diff-mat-right-eigenrefeqndiv-diff-mat-left-eigen) is prone to the same kind of catastrophic cancellation as is eqrefeqndiv-diff-recursive, so to evaluate eqrefeqndiv-diff-mat-fun, one instead turns to Taylor or Padé expansions of f(matZ_ij) (McCurdy 1984, Caliari 2004), or interpolation polynomial basis changes (Zivcovich 2019).","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"As an illustration, we show the divided differences of exp over 100 points uniformly spread over -22, calculated using eqrefeqndiv-diff-recursive, in Float64 and BigFloat precision, along with a Taylor expansion of eqrefeqndiv-diff-mat-fun:","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"(Image: Illustration of divided differences accuracy)","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"It can clearly be seen that the Taylor expansion is not susceptible to the catastrophic cancellation; it is however, not valid outside the interval -159159, so the domain of interest has to be rescaled prior to its usage.","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"MatrixPolynomials.⏃\nMatrixPolynomials.std_div_diff\nMatrixPolynomials.φₖ_ts_div_diff\nMatrixPolynomials.φₖ_div_diff\nMatrixPolynomials.div_diff_table\nMatrixPolynomials.min_degree\nMatrixPolynomials.taylor_series","category":"page"},{"location":"divided_differences/#MatrixPolynomials.⏃","page":"Divided differences","title":"MatrixPolynomials.⏃","text":"⏃(f, ξ, args...)\n\nCompute the divided differences of f at ξ, using a method that is optimized for the function f, if one is available, otherwise fallback to MatrixPolynomials.std_div_diff.\n\n\n\n\n\n","category":"function"},{"location":"divided_differences/#MatrixPolynomials.std_div_diff","page":"Divided differences","title":"MatrixPolynomials.std_div_diff","text":"std_div_diff(f, ξ, h, c, γ)\n\nCompute the divided differences of f at h*(c .+ γ*ξ), where ξ is a vector of (possibly complex) interpolation points, using the standard recursion formula.\n\n\n\n\n\n","category":"function"},{"location":"divided_differences/#MatrixPolynomials.φₖ_ts_div_diff","page":"Divided differences","title":"MatrixPolynomials.φₖ_ts_div_diff","text":"φₖ_ts_div_diff(k, ξ, h, c, γ[, τ=1])\n\nCompute the divided differences of φₖ at τ*h*(c .+ γ*ξ), where ξ is a vector of (possibly complex) interpolation points, using the algorithm in Table 2 of\n\nCaliari, M. (2007). Accurate evaluation of divided differences for polynomial interpolation of exponential propagators. Computing, 80(2), 189–201. DOI: 10.1007/s00607-007-0227-1\n\n\n\n\n\n","category":"function"},{"location":"divided_differences/#MatrixPolynomials.φₖ_div_diff","page":"Divided differences","title":"MatrixPolynomials.φₖ_div_diff","text":"φₖ_div_diff(k, ξ[; θ=3.5, s=1])\n\nSpecialized interface to div_diff_table for the φₖ functions. θ is the desired radius of convergence of the Taylor series of φₖ, and s is the scaling-and-squaring parameter, which if set to zero, will be calculated to fulfill θ.\n\n\n\n\n\n","category":"function"},{"location":"divided_differences/#MatrixPolynomials.div_diff_table","page":"Divided differences","title":"MatrixPolynomials.div_diff_table","text":"div_diff_table(f, ζ[; kwargs...])\n\nConstruct the table of divided differences of f at the interpolation points ζ, based on the algorithm on page 26 of\n\nZivcovich, F. (2019). Fast and accurate computation of divided differences for analytic functions, with an application to the exponential function. Dolomites Research Notes on Approximation, 12(1), 28–42.\n\n\n\n\n\n","category":"function"},{"location":"divided_differences/#MatrixPolynomials.min_degree","page":"Divided differences","title":"MatrixPolynomials.min_degree","text":"min_degree(::typeof(exp), θ)\n\nMinimum degree of Taylor polynomial to represent exp to machine precision, within a circle of radius θ.\n\n\n\n\n\n","category":"function"},{"location":"divided_differences/#MatrixPolynomials.taylor_series","page":"Divided differences","title":"MatrixPolynomials.taylor_series","text":"taylor_series(::Type{T}, ::typeof(exp), n; s=1, θ=3.5) where T\n\nCompute the Taylor series of exp(z/s), with n terms, or as many terms as required to achieve convergence within a circle of radius θ, whichever is largest.\n\n\n\n\n\n","category":"function"},{"location":"divided_differences/#Bibliography-1","page":"Divided differences","title":"Bibliography","text":"","category":"section"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"Caliari, M. (2007). Accurate evaluation of divided differences for polynomial interpolation of exponential propagators. Computing, 80(2), 189–201. DOI: 10.1007/s00607-007-0227-1","category":"page"},{"location":"divided_differences/#","page":"Divided differences","title":"Divided differences","text":"McCurdy, A. C., Ng, K. C., & Parlett, B. N. (1984). Accurate computation of divided differences of the exponential function. Mathematics of Computation, 43(168), 501–501. DOI: 10.1090/s0025-5718-1984-0758198-0\nOpitz, G. (1964). Steigungsmatrizen. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift für Angewandte Mathematik und Mechanik, 44(S1), DOI: 10.1002/zamm.19640441321\nZivcovich, F. (2019). Fast and accurate computation of divided differences for analytic functions, with an application to the exponential function. Dolomites Research Notes on Approximation, 12(1), 28–42. PDF: Zivcovich2019FAC.pdf","category":"page"},{"location":"phi_functions/#φₖ-functions-1","page":"φₖ functions","title":"φₖ functions","text":"","category":"section"},{"location":"phi_functions/#Definition-1","page":"φₖ functions","title":"Definition","text":"","category":"section"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"These are defined recursively through","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nlabeleqnphi-k-recursive\nvarphi_0(z) defd ce^z quad\nvarphi_1(z) defd fracce^z-1z quad\nvarphi_k+1(z) defd fracvarphi_k(z)-varphi_k(0)z quad\nvarphi_k(0)=frac1k\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"An alternate definition is","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nh^k varphi_k(hz) = int_0^h diffs\nce^(h-s)z fracs^k-1(k-1)\nendequation","category":"page"},{"location":"phi_functions/#Accuracy-1","page":"φₖ functions","title":"Accuracy","text":"","category":"section"},{"location":"phi_functions/#Accuracy-for-k1-1","page":"φₖ functions","title":"Accuracy for k=1","text":"","category":"section"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nlabeleqnphi-1-naive\nvarphi_1(z) equiv fracce^z-1z\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"This is a common example of catastrophic cancellation; for small absz, ce^z - 1approx 0, and we thus divide a small number by a small number. By employing a trick shown by e.g.","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"Higham, N. (2002). Accuracy and stability of numerical\nalgorithms. Philadelphia: Society for Industrial and Applied\nMathematics.","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"we can substantially improve accuracy:","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nlabeleqnphi-1-accurate\nvarphi_1(z) = begincases\n1  absz  varepsilon\nfracce^z-1logce^z  varepsilon  absz  1 \nfracce^z-1z  textrmelse\nendcases\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"(Image: Illustration of φ₁ accuracy)","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"The solid line corresponds to the naïve implementation eqrefeqnphi-1-naive, whereas the dashed line corresponds to the accurate implementation eqrefeqnphi-1-accurate.","category":"page"},{"location":"phi_functions/#Accuracy-for-k-1-1","page":"φₖ functions","title":"Accuracy for k  1","text":"","category":"section"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"For a Taylor expansion of a function f(x), we have","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nf(x-a) = underbracesum_i=0^n fracf^(i)(a)i (x-a)^i_defd T_n(x) +\nunderbracefracf^(n+1)(xi)(n+1)(x-a)^n+1_defd R_n(x) quad\nxi in ax\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"We now Taylor expand ce^(h-s)z about z=0:","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nce^(h-s)z =\nsum_i=0^n fracz^i(h-s)^ii +\nfracce^(h-s)zetazeta^n+1(h-s)^n+1(n+1)\nquad abszeta leq z\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"With this, we now calculate the definite integral appearing in the definition of varphi_k:","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nbeginaligned\nint_0^hdiffs\nce^(h-s)z s^k-1\n=\nint_0^hdiffs\nsum_i=0^n fracz^i(h-s)^is^k-1i +\nint_0^hdiffs\nfracce^(h-s)zetazeta^n+1(h-s)^n+1s^k-1(n+1) \n=\nsum_i=0^n\nfracz^ii\nint_0^hdiffs\n(h-s)^is^k-1 +\nint_0^hdiffs\nfracce^(h-s)zetazeta^n+1(h-s)^n+1s^k-1(n+1)\nendaligned\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"For the case we are interested in, h=1 and the first integral is equivalent to Euler's beta function:","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nint_0^1diffs s^k-1(1-s)^i equiv Beta(ki+1) equiv fracGamma(k)Gamma(i+1)Gamma(k+i+1)\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"which, for integer ki has the following value","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nBeta(ki+1) = frac(k-1)i(k+i)\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"Inserting this into the integral (having set h=1), we find","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"beginequation\nlabeleqnphi-k-expansion\nvarphi_k(z) =\nsum_i=0^n\nfracz^i(k+i)\n+int_0^1diffs R_n(szeta)\nendequation","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"where we have made explicit the dependence of the Lagrange remainder R_n(szeta) on s.","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"Some numerical testing seems to indicate it is enough to set n=k in the Taylor expansion eqrefeqnphi-k-expansion to get accurate evaluation of phi_k(x) for small absx, xinmathbbR. For general z, the amount of required terms seems higher, so n is currently set to 10k.","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"(Image: Illustration of φ₁ accuracy)","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"The plot includes phi_k(z) for kin0100. To illustrate the rounding errors that would occur if one were to use the recursive definition eqrefeqnphi-k-recursive directly , we plot varphi_k(x), but for kin04 only:","category":"page"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"(Image: Illustration of φ₁ accuracy)","category":"page"},{"location":"phi_functions/#Reference-1","page":"φₖ functions","title":"Reference","text":"","category":"section"},{"location":"phi_functions/#","page":"φₖ functions","title":"φₖ functions","text":"MatrixPolynomials.φ₁\nMatrixPolynomials.φ","category":"page"},{"location":"phi_functions/#MatrixPolynomials.φ₁","page":"φₖ functions","title":"MatrixPolynomials.φ₁","text":"φ₁(z)\n\nSpecial case of φ for k=1, taking care to avoid numerical rounding errors for small z.\n\n\n\n\n\n","category":"function"},{"location":"phi_functions/#MatrixPolynomials.φ","page":"φₖ functions","title":"MatrixPolynomials.φ","text":"φ(k, z)\n\nCompute the entire function varphi_k(z), zinmathbbC, which is recursively defined as [Eq. (2.11) of Hochbruck2010]\n\nvarphi_k+1(z) equiv fracvarphi_k(z)-varphi_k(0)z\n\nwith the base cases\n\nvarphi_0(z) = exp(z) quad\nvarphi_1(z) = fracexp(z)-1z\n\nand the special case\n\nvarphi_k(0) = frac1k\n\nThis function, as the base case φ₁, is implemented to avoid rounding errors for small z.\n\n\n\n\n\nφ(k)\n\nReturn a function corresponding to φₖ.\n\nExamples\n\njulia> φ(0)\nexp (generic function with 14 methods)\n\njulia> φ(1)\nφ₁ (generic function with 1 method)\n\njulia> φ(2)\nφ₂ (generic function with 1 method)\n\njulia> φ(15)\nφ₁₅ (generic function with 1 method)\n\njulia> φ(15)(5.0 + im)\n1.0931836313419128e-12 + 9.301475570434819e-14im\n\n\n\n\n\n","category":"function"},{"location":"newton_polynomials/#Newton-polynomials-1","page":"Newton polynomials","title":"Newton polynomials","text":"","category":"section"},{"location":"newton_polynomials/#","page":"Newton polynomials","title":"Newton polynomials","text":"MatrixPolynomials.NewtonPolynomial\nMatrixPolynomials.NewtonMatrixPolynomial","category":"page"},{"location":"newton_polynomials/#MatrixPolynomials.NewtonPolynomial","page":"Newton polynomials","title":"MatrixPolynomials.NewtonPolynomial","text":"NewtonPolynomial(ζ, d)\n\nThe unique interpolation polynomial of a function in its Newton form, i.e.\n\nf(z) approx p(z) = sum_j=1^m fzeta_1zeta_j prod_i=1^j-1(z - zeta_i)\n\nwhere ζ are the interpolation points and d[j]=f[ζ₁,...,ζⱼ] is the jth divided difference of the interpolated function f.\n\n\n\n\n\n","category":"type"},{"location":"#MatrixPolynomials.jl-1","page":"Home","title":"MatrixPolynomials.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"}]
}
