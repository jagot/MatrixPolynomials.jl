<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Divided differences · MatrixPolynomials.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/latex.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MatrixPolynomials.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../funcv/">Functions of matrices</a></li><li><a class="tocitem" href="../leja/">Leja points</a></li><li class="is-active"><a class="tocitem" href>Divided differences</a><ul class="internal"><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li><li><a class="tocitem" href="#Bibliography"><span>Bibliography</span></a></li></ul></li><li><a class="tocitem" href="../newton_polynomials/">Newton polynomials</a></li><li><a class="tocitem" href="../phi_functions/">φₖ functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Divided differences</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Divided differences</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jagot/MatrixPolynomials.jl/blob/master/docs/src/divided_differences.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Divided-differences"><a class="docs-heading-anchor" href="#Divided-differences">Divided differences</a><a id="Divided-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Divided-differences" title="Permalink"></a></h1><p>The divided differences of a function <span>$f$</span> with respect to a set of interpolation points <span>$\{\zeta_i\}$</span> is defined as <sup class="footnote-reference"><a id="citeref-McCurdy" href="#footnote-McCurdy">[McCurdy]</a></sup></p><p class="math-container">\[\begin{equation}
\label{eqn:div-diff-def}
\divdiff(\zeta_{i:j})f \defd
\frac{1}{2\pi\im}
\oint
\diff{z}
\frac{f(z)}{(z-\zeta_i)(z-\zeta_{i+1})...(z-\zeta_j)},
\end{equation}\]</p><p>where the integral is taken along a simple contour encircling the poles once. A common approach to evaluate the divided differences of <span>$f$</span>, and an alternative definition, is the recursive scheme</p><p class="math-container">\[\begin{equation}
\label{eqn:div-diff-recursive}
\tag{\ref{eqn:div-diff-def}*}
\divdiff(\zeta_{i:j},z)f \defd
\frac{\divdiff(\zeta_{i:j-1},z)f-\divdiff(\zeta_{i:j})f}{z - \zeta_j}, \quad
\divdiff(\zeta_i,z)f \defd
\frac{\divdiff(z)f-\divdiff(\zeta_i)f}{z - \zeta_i}, \quad
\divdiff(z)f \defd f(z),
\end{equation}\]</p><p>which, however, is prone to catastrophic cancellation for very small <span>$\abs{\zeta_i-\zeta_j}$</span>. This can be partially alleviated by employing <code>BigFloat</code>s, but that will only postpone the breakdown, albeit with ~40 orders of magnitude, which might be enough for practical purposes (but much slower).</p><p><a href="#MatrixPolynomials.ts_div_diff_table"><code>MatrixPolynomials.ts_div_diff_table</code></a> is based upon the fact the divided differences in a third way can be computed as <sup class="footnote-reference"><a id="citeref-McCurdy" href="#footnote-McCurdy">[McCurdy]</a></sup><sup class="footnote-reference"><a id="citeref-Opitz" href="#footnote-Opitz">[Opitz]</a></sup></p><p class="math-container">\[\begin{equation}
\label{eqn:div-diff-mat-fun}
\tag{\ref{eqn:div-diff-def}†}
\divdiff(\zeta_{i:j})f \defd
\vec{e}_1^\top
f(\mat{Z}_{i:j}),
\end{equation}\]</p><p>i.e. the first row of the function <span>$f$</span> applied to the matrix</p><p class="math-container">\[\begin{equation}
\mat{Z}_{i:j}\defd
\bmat{
\zeta_i&amp;1&amp;\\
&amp;\zeta_{i+1}&amp;1\\
&amp;&amp;\ddots&amp;\ddots\\
&amp;&amp;&amp;\ddots&amp;1\\
&amp;&amp;&amp;&amp;\zeta_j}.
\end{equation}\]</p><p>The right-eigenvectors are given by [Opitz]</p><p class="math-container">\[\begin{equation}
\label{eqn:div-diff-mat-right-eigen}
\mat{Q}_\zeta = \{q_{ik}\}, \quad
q_{ik} =
\begin{cases}
\prod_{j=i}^{k-1} (\zeta_k - \zeta_j)^{-1}, &amp; i &lt; k,\\
1, &amp; i = k,\\
0, &amp; \textrm{else},
\end{cases}
\end{equation}\]</p><p>and similarly, the left-eigenvectors are given by</p><p class="math-container">\[\begin{equation}
\label{eqn:div-diff-mat-left-eigen}
\tag{\ref{eqn:div-diff-mat-right-eigen}*}
\mat{Q}_\zeta^{-1} = \{\conj{q}_{ik}\}, \quad
\conj{q}_{ik} =
\begin{cases}
\prod_{j=i+1}^k (\zeta_i - \zeta_j)^{-1}, &amp; i &lt; k,\\
1, &amp; i = k,\\
0, &amp; \textrm{else},
\end{cases}
\end{equation}\]</p><p>such that</p><p class="math-container">\[\begin{equation}
\divdiff(\zeta_{i:j})f=
\mat{Q}_\zeta\mat{F}_\zeta\mat{Q}_\zeta^{-1},\quad
\mat{F}_\zeta \defd \bmat{f(\zeta_i)\\&amp;f(\zeta_{i+1})\\&amp;&amp;\ddots\\&amp;&amp;&amp;f(\zeta_j)}.
\end{equation}\]</p><p>However, straight evaluation of <span>$(\ref{eqn:div-diff-mat-right-eigen},\ref{eqn:div-diff-mat-left-eigen})$</span> is prone to the same kind of catastrophic cancellation as is <span>$\eqref{eqn:div-diff-recursive}$</span>, so to evaluate <span>$\eqref{eqn:div-diff-mat-fun}$</span>, one instead turns to Taylor or <a href="https://en.wikipedia.org/wiki/Pad%C3%A9_approximant">Padé</a> expansions of <span>$f(\mat{Z}_{i:j})$</span> <sup class="footnote-reference"><a id="citeref-McCurdy" href="#footnote-McCurdy">[McCurdy]</a></sup><sup class="footnote-reference"><a id="citeref-Caliari" href="#footnote-Caliari">[Caliari]</a></sup>, or interpolation polynomial basis changes <sup class="footnote-reference"><a id="citeref-Zivcovich" href="#footnote-Zivcovich">[Zivcovich]</a></sup>.</p><p>As an illustration, we show the divided differences of <code>exp</code> over 100 points uniformly spread over <span>$[-2,2]$</span>, calculated using <span>$\eqref{eqn:div-diff-recursive}$</span>, in <code>Float64</code> and <code>BigFloat</code> precision, along with a Taylor expansion of <span>$\eqref{eqn:div-diff-mat-fun}$</span>:</p><p><img src="../figures/div_differences_cancellation.svg" alt="Illustration of divided differences accuracy"/></p><p>It can clearly be seen that the Taylor expansion is not susceptible to the catastrophic cancellation.</p><p>Thanks to the general implementation of divided differences using Taylor expansions of the desired function, it is very easy to generate <a href="../newton_polynomials/#Newton-polynomials">Newton polynomials</a> approximating the function on an interval:</p><pre><code class="language-julia-repl">julia&gt; import MatrixPolynomials: Leja, points, NewtonPolynomial, ⏃

julia&gt; μ = 10.0 # Extent of interval
10.0

julia&gt; m = 40 # Number of Leja points
40

julia&gt; ζ = points(Leja(μ*range(-1,stop=1,length=1000),m))
40-element Array{Float64,1}:
  10.0
 -10.0
  -0.01001001001001001
   5.7757757757757755
  -6.596596596596597
   8.398398398398399
  -8.6986986986987
  -3.053053053053053
   3.2132132132132134
   9.43943943943944
  -9.51951951951952
  -4.794794794794795
   7.137137137137137
   1.5515515515515514
  -7.757757757757758
   9.7997997997998
  -1.6116116116116117
  -9.83983983983984
   4.614614614614615
   8.91891891891892
  -5.7157157157157155
   2.3723723723723724
  -9.11911911911912
   7.757757757757758
  -3.873873873873874
   6.416416416416417
  -8.218218218218219
   9.91991991991992
  -0.8108108108108109
  -9.93993993993994
   3.973973973973974
  -7.137137137137137
   9.1991991991992
  -2.3523523523523524
   0.8108108108108109
  -9.67967967967968
   9.63963963963964
   5.235235235235235
  -5.275275275275275
   8.078078078078079

julia&gt; d = ⏃(sin, ζ, 1, 0, 1)
40-element Array{Float64,1}:
 -0.5440211108893093
 -0.05440211108893093
  0.00010554419095304635
  0.00042707706157334835
  0.00017816519362596795
 -0.00015774261733182256
 -3.046393737965622e-6
 -1.7726427136510242e-6
 -1.2091185654301347e-7
  8.298167162094031e-8
  1.623156704750302e-9
 -2.1182984780033414e-9
  3.072198477098241e-11
  2.690974958064657e-11
  7.708729505182354e-13
 -1.385345395017015e-13
  2.081712029555509e-15
  6.103669805230243e-16
  4.2232933731665444e-18
 -2.098152059762693e-18
  7.153277579328475e-21
  6.390881616124369e-21
  7.322223484376659e-23
 -1.3419887223602703e-23
 -4.050939196813086e-26
  2.4794777140850798e-26
  1.268544482329477e-28
 -3.581342740292682e-29
  2.7876085130074983e-31
  4.786776652095869e-32
  8.943705105911237e-36
 -5.432439158165548e-35
  9.88206793819289e-38
  5.559232062626121e-38
 -1.2016071877913981e-41
 -4.710497689585078e-41
  7.660823607389171e-45
  3.728816926131357e-44
 -4.378275580359998e-48
 -2.577149389756008e-47

julia&gt; np = NewtonPolynomial(ζ, d)
Newton polynomial of degree 39 on -10.0..10.0

julia&gt; x = range(-μ, stop=μ, length=1000)
-10.0:0.02002002002002002:10.0

julia&gt; f_np = np.(x);

julia&gt; f_exact = sin.(x);</code></pre><p>Behind the scenes, <a href="#MatrixPolynomials.taylor_series"><code>MatrixPolynomials.taylor_series</code></a> is used to generate the Taylor expansion of <span>$\sin(x)$</span>, and when an approximation of <span>$\sin(\tau \mat{Z})$</span> has been computed, the full divided difference table <span>$\sin(\mat{Z})$</span> is recovered using <a href="#MatrixPolynomials.propagate_div_diff"><code>MatrixPolynomials.propagate_div_diff</code></a>.</p><p><img src="../figures/div_differences_sine.svg" alt="Reconstruction of sine using divided differences"/></p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.⏃" href="#MatrixPolynomials.⏃"><code>MatrixPolynomials.⏃</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⏃(f, ζ, args...)</code></pre><p>Compute the divided differences of <code>f</code> at <code>ζ</code>, using a method that is optimized for the function <code>f</code>, if one is available, otherwise fallback to <a href="#MatrixPolynomials.ts_div_diff_table"><code>MatrixPolynomials.ts_div_diff_table</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/divided_differences.jl#LL54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.std_div_diff" href="#MatrixPolynomials.std_div_diff"><code>MatrixPolynomials.std_div_diff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">std_div_diff(f, ζ, h, c, γ)</code></pre><p>Compute the divided differences of <code>f</code> at <code>h*(c .+ γ*ζ)</code>, where <code>ζ</code> is a vector of (possibly complex) interpolation points, using the standard recursion formula.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/divided_differences.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.ts_div_diff_table" href="#MatrixPolynomials.ts_div_diff_table"><code>MatrixPolynomials.ts_div_diff_table</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ts_div_diff_table(f, ζ, h, c, γ; kwargs...)</code></pre><p>Compute the divided differences of <code>f</code> at <code>h*(c .+ γ*ζ)</code>, where <code>ζ</code> is a vector of (possibly complex) interpolation points, by forming the full divided differences table using the Taylor series of <code>f(H)</code> (computed using <a href="#MatrixPolynomials.taylor_series"><code>taylor_series</code></a>). If there is a scaling relationship available for <code>f</code>, the Taylor series of <code>f(τ*H)</code> is computed instead, and the full solution is recovered using <a href="#MatrixPolynomials.propagate_div_diff"><code>propagate_div_diff</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/divided_differences.jl#LL20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.φₖ_div_diff_basis_change" href="#MatrixPolynomials.φₖ_div_diff_basis_change"><code>MatrixPolynomials.φₖ_div_diff_basis_change</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">φₖ_div_diff_basis_change(k, ζ[; θ=3.5, s=1])</code></pre><p>Specialized interface to <a href="#MatrixPolynomials.div_diff_table_basis_change"><code>div_diff_table_basis_change</code></a> for the <code>φₖ</code> functions. <code>θ</code> is the desired radius of convergence of the Taylor series of <code>φₖ</code>, and <code>s</code> is the scaling-and-squaring parameter, which if set to zero, will be calculated to fulfill <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/divided_differences.jl#LL131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.div_diff_table_basis_change" href="#MatrixPolynomials.div_diff_table_basis_change"><code>MatrixPolynomials.div_diff_table_basis_change</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">div_diff_table_basis_change(f, ζ[; kwargs...])</code></pre><p>Construct the table of divided differences of <code>f</code> at the interpolation points <code>ζ</code>, based on the algorithm on page 26 of</p><ul><li>Zivcovich, F. (2019). Fast and accurate computation of divided differences for analytic functions, with an application to the exponential function. Dolomites Research Notes on Approximation, 12(1), 28–42.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/divided_differences.jl#LL96-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.min_degree" href="#MatrixPolynomials.min_degree"><code>MatrixPolynomials.min_degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">min_degree(::typeof(exp), θ)</code></pre><p>Minimum degree of Taylor polynomial to represent <code>exp</code> to machine precision, within a circle of radius <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/divided_differences.jl#LL72-L77">source</a></section></article><h3 id="Taylor-series"><a class="docs-heading-anchor" href="#Taylor-series">Taylor series</a><a id="Taylor-series-1"></a><a class="docs-heading-anchor-permalink" href="#Taylor-series" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.TaylorSeries" href="#MatrixPolynomials.TaylorSeries"><code>MatrixPolynomials.TaylorSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TaylorSeries(d, c)</code></pre><p>Represents the Taylor series of a function as</p><p class="math-container">\[f(x) = \sum_{k=0}^\infty c_k x^{d_k},\]</p><p>where <code>dₖ = d(k)</code> and <code>cₖ = c(k)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/taylor_series.jl#LL1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.taylor_series" href="#MatrixPolynomials.taylor_series"><code>MatrixPolynomials.taylor_series</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">taylor_series(::typeof(exp))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>exp(x) = ∑ₖ x^(k) 1 / Γ(k + 1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(exp)

1 + x + 0.5x^2 + 0.16666666666666666x^3 + ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/taylor_series.jl#LL94-L105">source</a></section><section><div><pre><code class="language-none">taylor_series(::typeof(sin))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>sin(x) = ∑ₖ x^(2k + 1) (-1) ^ k / Γ(2k + 2)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(sin)

x - 0.16666666666666666x^3 + 0.008333333333333333x^5 - 0.0001984126984126984x^7 + ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/taylor_series.jl#LL94-L105">source</a></section><section><div><pre><code class="language-none">taylor_series(::typeof(cos))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>cos(x) = ∑ₖ x^(2k) (-1) ^ k / Γ(2k + 1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(cos)

1 - 0.5x^2 + 0.041666666666666664x^4 - 0.001388888888888889x^6 + ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/taylor_series.jl#LL94-L105">source</a></section><section><div><pre><code class="language-none">taylor_series(::typeof(sinh))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>sinh(x) = ∑ₖ x^(2k + 1) 1 / Γ(2k + 2)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(sinh)

x + 0.16666666666666666x^3 + 0.008333333333333333x^5 + 0.0001984126984126984x^7 + ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/taylor_series.jl#LL94-L105">source</a></section><section><div><pre><code class="language-none">taylor_series(::typeof(cosh))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>cosh(x) = ∑ₖ x^(2k) 1 / Γ(2k + 1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(cosh)

1 + 0.5x^2 + 0.041666666666666664x^4 + 0.001388888888888889x^6 + ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/taylor_series.jl#LL94-L105">source</a></section><section><div><pre><code class="language-none">taylor_series(::typeof(φ₁))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>φ₁(x) = ∑ₖ x^(k) 1 / Γ(k + 2)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(φ₁)

1 + 0.5x + 0.16666666666666666x^2 + 0.041666666666666664x^3 + ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/taylor_series.jl#LL94-L105">source</a></section><section><div><pre><code class="language-none">taylor_series(::Type{T}, ::typeof(exp), n; s=1, θ=3.5) where T</code></pre><p>Compute the Taylor series of <code>exp(z/s)</code>, with <code>n</code> terms, or as many terms as required to achieve convergence within a circle of radius <code>θ</code>, whichever is largest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/divided_differences.jl#LL84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.closure" href="#MatrixPolynomials.closure"><code>MatrixPolynomials.closure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closure(x::Number)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/matrix_closures.jl#LL1-L5">source</a></section><section><div><pre><code class="language-none">closure(x::Matrix)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>Matrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/matrix_closures.jl#LL15-L19">source</a></section><section><div><pre><code class="language-none">closure(x::Diagonal)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>Diagonal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/matrix_closures.jl#LL15-L19">source</a></section><section><div><pre><code class="language-none">closure(x::LowerTriangular)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>LowerTriangular</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/matrix_closures.jl#LL15-L19">source</a></section><section><div><pre><code class="language-none">closure(x::UpperTriangular)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>UpperTriangular</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/matrix_closures.jl#LL15-L19">source</a></section><section><div><pre><code class="language-none">closure(x::Bidiagonal)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>UpperTriangular</code> or <code>LowerTriangular</code>, depending on <code>x.uplo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/matrix_closures.jl#LL29-L34">source</a></section></article><h3 id="Scaling"><a class="docs-heading-anchor" href="#Scaling">Scaling</a><a id="Scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Scaling" title="Permalink"></a></h3><p>For the computation of <span>$\exp(A)$</span>, a common approach when <span>$|A|$</span> is large is to compute <span>$[\exp(A/s)]^s$</span> instead. This is known as <em>scaling and squaring</em>, if <span>$s$</span> is selected to be a power-of-two. Similar relationships can be found for other functions and are implemented for some using <a href="#MatrixPolynomials.propagate_div_diff"><code>MatrixPolynomials.propagate_div_diff</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.propagate_div_diff" href="#MatrixPolynomials.propagate_div_diff"><code>MatrixPolynomials.propagate_div_diff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagate_div_diff(::typeof(exp), expτH, J, args...)</code></pre><p>Find the divided differences of <code>exp</code> by utilizing that <span>$\exp(a+b)=\exp(a)\exp(b)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/propagate_divided_differences.jl#LL22-L27">source</a></section><section><div><pre><code class="language-none">propagate_div_diff(::typeof(φ₁), φ₁H, J, H, τ)</code></pre><p>Find the divided differences of <code>φ₁</code> by solving the ODE</p><p class="math-container">\[\dot{\vec{y}}(t) = \mat{H} \vec{y}(t) + \vec{e}_1, \quad \vec{y}(0) = 0,\]</p><p>by iterating</p><p class="math-container">\[\vec{y}_{j+1} = \vec{y}_j + \tau\varphi_1(\tau\mat{H})(\mat{H}\vec{y}_j + \vec{e}_1),
\quad j=0,...,J-1.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/propagate_divided_differences.jl#LL36-L48">source</a></section><section><div><pre><code class="language-none">propagate_div_diff(::typeof(sin), sinH, J, H, τ)</code></pre><p>Find the divided differences of <code>sin</code>; see <a href="#MatrixPolynomials.propagate_div_diff_sin_cos"><code>propagate_div_diff_sin_cos</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/propagate_divided_differences.jl#LL87-L92">source</a></section><section><div><pre><code class="language-none">propagate_div_diff(::typeof(cos), cosH, J, H, τ)</code></pre><p>Find the divided differences of <code>cos</code>; see <a href="#MatrixPolynomials.propagate_div_diff_sin_cos"><code>propagate_div_diff_sin_cos</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/propagate_divided_differences.jl#LL98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MatrixPolynomials.propagate_div_diff_sin_cos" href="#MatrixPolynomials.propagate_div_diff_sin_cos"><code>MatrixPolynomials.propagate_div_diff_sin_cos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagate_div_diff_sin_cos(sinH, cosH, J)</code></pre><p>Find the divided differences tables of <code>sin</code> and <code>cos</code> simultaneously, by utilizing the double-angle formulæ</p><p class="math-container">\[\sin2\theta = 2\sin\theta\cos\theta, \quad
\cos2\theta = 1 - \sin^2\theta,\]</p><p>recursively, doubling the angle at each iteration until the desired angle is achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/6dcda7fed30a260f734063c841e91a92870598f1/src/propagate_divided_differences.jl#LL61-L72">source</a></section></article><h2 id="Bibliography"><a class="docs-heading-anchor" href="#Bibliography">Bibliography</a><a id="Bibliography-1"></a><a class="docs-heading-anchor-permalink" href="#Bibliography" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Caliari"><a class="tag is-link" href="#citeref-Caliari">Caliari</a>Caliari, M. (2007). Accurate evaluation of divided differences for polynomial interpolation of exponential propagators. Computing, 80(2), 189–201. <a href="http://dx.doi.org/10.1007/s00607-007-0227-1">DOI: 10.1007/s00607-007-0227-1</a></li><li class="footnote" id="footnote-Kandolf"><a class="tag is-link" href="#citeref-Kandolf">Kandolf</a>Kandolf, P., Ostermann, A., &amp; Rainer, S. (2014). A residual based error estimate for Leja interpolation of matrix functions. Linear Algebra and its Applications, 456(nil), 157–173. <a href="http://dx.doi.org/10.1016/j.laa.2014.04.023">DOI: 10.1016/j.laa.2014.04.023</a></li><li class="footnote" id="footnote-McCurdy"><a class="tag is-link" href="#citeref-McCurdy">McCurdy</a>McCurdy, A. C., Ng, K. C., &amp; Parlett, B. N. (1984). Accurate computation of divided differences of the exponential function. Mathematics of Computation, 43(168), 501–501. <a href="http://dx.doi.org/10.1090/s0025-5718-1984-0758198-0">DOI: 10.1090/s0025-5718-1984-0758198-0</a></li><li class="footnote" id="footnote-Opitz"><a class="tag is-link" href="#citeref-Opitz">Opitz</a>Opitz, G. (1964). Steigungsmatrizen. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift für Angewandte Mathematik und Mechanik, 44(S1), <a href="http://dx.doi.org/10.1002/zamm.19640441321">DOI: 10.1002/zamm.19640441321</a></li><li class="footnote" id="footnote-Zivcovich"><a class="tag is-link" href="#citeref-Zivcovich">Zivcovich</a>Zivcovich, F. (2019). Fast and accurate computation of divided differences for analytic functions, with an application to the exponential function. Dolomites Research Notes on Approximation, 12(1), 28–42. <a href="https://drna.padovauniversitypress.it/system/files/papers/Zivcovich_2019_FAC.pdf">PDF: Zivcovich<em>2019</em>FAC.pdf</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../leja/">« Leja points</a><a class="docs-footer-nextpage" href="../newton_polynomials/">Newton polynomials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 6 September 2022 14:36">Tuesday 6 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
