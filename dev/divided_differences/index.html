<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Divided differences · MatrixPolynomials.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><h1>MatrixPolynomials.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../phi_functions/">φₖ functions</a></li><li class="current"><a class="toctext" href>Divided differences</a><ul class="internal"><li><a class="toctext" href="#Reference-1">Reference</a></li><li><a class="toctext" href="#Bibliography-1">Bibliography</a></li></ul></li><li><a class="toctext" href="../newton_polynomials/">Newton polynomials</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Divided differences</a></li></ul><a class="edit-page" href="https://github.com/jagot/MatrixPolynomials.jl/blob/master/docs/src/divided_differences.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Divided differences</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Divided-differences-1" href="#Divided-differences-1">Divided differences</a></h1><p>The divided differences of a function <span>$f$</span> with respect to a set of interpolation points <span>$\{\zeta_i\}$</span> is defined as (<a href="#Bibliography-1">McCurdy 1984</a>)</p><div>\[\begin{equation}
\label{eqn:div-diff-def}
\divdiff(\zeta_{i:j})f \defd
\frac{1}{2\pi\im}
\oint
\diff{z}
\frac{f(z)}{(z-\zeta_i)(z-\zeta_{i+1})...(z-\zeta_j)},
\end{equation}\]</div><p>where the integral is taken along a simple contour encircling the poles once. A common approach to evaluate the divided differences of <span>$f$</span>, and an alternative definition, is the recursive scheme</p><div>\[\begin{equation}
\label{eqn:div-diff-recursive}
\tag{\ref{eqn:div-diff-def}*}
\divdiff(\zeta_{i:j},z)f \defd
\frac{\divdiff(\zeta_{i:j-1},z)f-\divdiff(\zeta_{i:j})f}{z - \zeta_j}, \quad
\divdiff(\zeta_i,z)f \defd
\frac{\divdiff(z)f-\divdiff(\zeta_i)f}{z - \zeta_i}, \quad
\divdiff(z)f \defd f(z),
\end{equation}\]</div><p>which, however, is prone to catastrophic cancellation for very small <span>$\abs{\zeta_i-\zeta_j}$</span>. This can be partially alleviated by employing <code>BigFloat</code>s, but that will only postpone the breakdown, albeit with ~40 orders of magnitude, which might be enough for practical purposes (but much slower).</p><p><a href="#MatrixPolynomials.ts_div_diff_table"><code>MatrixPolynomials.ts_div_diff_table</code></a> is based upon the fact the divided differences in a third way can be computed as (<a href="#Bibliography-1">McCurdy 1984</a>, <a href="#Bibliography-1">Opitz 1964</a>)</p><div>\[\begin{equation}
\label{eqn:div-diff-mat-fun}
\tag{\ref{eqn:div-diff-def}†}
\divdiff(\zeta_{i:j})f \defd
\vec{e}_1^\top
f(\mat{Z}_{i:j}),
\end{equation}\]</div><p>i.e. the first row of the function <span>$f$</span> applied to the matrix</p><div>\[\begin{equation}
\mat{Z}_{i:j}\defd
\bmat{
\zeta_i&amp;1&amp;\\
&amp;\zeta_{i+1}&amp;1\\
&amp;&amp;\ddots&amp;\ddots\\
&amp;&amp;&amp;\ddots&amp;1\\
&amp;&amp;&amp;&amp;\zeta_j}.
\end{equation}\]</div><p>The right-eigenvectors are given by (<a href="#Bibliography-1">Opitz 1964</a>)</p><div>\[\begin{equation}
\label{eqn:div-diff-mat-right-eigen}
\mat{Q}_\zeta = \{q_{ik}\}, \quad
q_{ik} =
\begin{cases}
\prod_{j=i}^{k-1} (\zeta_k - \zeta_j)^{-1}, &amp; i &lt; k,\\
1, &amp; i = k,\\
0, &amp; \textrm{else},
\end{cases}
\end{equation}\]</div><p>and similarly, the left-eigenvectors are given by</p><div>\[\begin{equation}
\label{eqn:div-diff-mat-left-eigen}
\tag{\ref{eqn:div-diff-mat-right-eigen}*}
\mat{Q}_\zeta^{-1} = \{\conj{q}_{ik}\}, \quad
\conj{q}_{ik} =
\begin{cases}
\prod_{j=i+1}^k (\zeta_i - \zeta_j)^{-1}, &amp; i &lt; k,\\
1, &amp; i = k,\\
0, &amp; \textrm{else},
\end{cases}
\end{equation}\]</div><p>such that</p><div>\[\begin{equation}
\divdiff(\zeta_{i:j})f=
\mat{Q}_\zeta\mat{F}_\zeta\mat{Q}_\zeta^{-1},\quad
\mat{F}_\zeta \defd \bmat{f(\zeta_i)\\&amp;f(\zeta_{i+1})\\&amp;&amp;\ddots\\&amp;&amp;&amp;f(\zeta_j)}.
\end{equation}\]</div><p>However, straight evaluation of <span>$(\ref{eqn:div-diff-mat-right-eigen},\ref{eqn:div-diff-mat-left-eigen})$</span> is prone to the same kind of catastrophic cancellation as is <span>$\eqref{eqn:div-diff-recursive}$</span>, so to evaluate <span>$\eqref{eqn:div-diff-mat-fun}$</span>, one instead turns to Taylor or <a href="https://en.wikipedia.org/wiki/Pad%C3%A9_approximant">Padé</a> expansions of <span>$f(\mat{Z}_{i:j})$</span> (<a href="#Bibliography-1">McCurdy 1984</a>, <a href="#Bibliography-1">Caliari 2004</a>), or interpolation polynomial basis changes (<a href="#Bibliography-1">Zivcovich 2019</a>).</p><p>As an illustration, we show the divided differences of <code>exp</code> over 100 points uniformly spread over <span>$[-2,2]$</span>, calculated using <span>$\eqref{eqn:div-diff-recursive}$</span>, in <code>Float64</code> and <code>BigFloat</code> precision, along with a Taylor expansion of <span>$\eqref{eqn:div-diff-mat-fun}$</span>:</p><p><img src="../figures/div_differences_cancellation.svg" alt="Illustration of divided differences accuracy"/></p><p>It can clearly be seen that the Taylor expansion is not susceptible to the catastrophic cancellation.</p><p>Thanks to the general implementation of divided differences using Taylor expansions of the desired function, it is very easy to generate <a href="../newton_polynomials/#Newton-polynomials-1">Newton polynomials</a> approximating the function on an interval:</p><pre><code class="language-julia-repl">julia&gt; import MatrixPolynomials: Leja, points, NewtonPolynomial, ⏃

julia&gt; μ = 10.0 # Extent of interval
10.0

julia&gt; m = 40 # Number of Leja points
40

julia&gt; ζ = points(Leja(μ*range(-1,stop=1,length=1000),m))
40-element Array{Float64,1}:
  10.0
 -10.0
  -0.01001001001001001
   5.7757757757757755
  -6.596596596596597
   8.398398398398399
  -8.6986986986987
  -3.053053053053053
   3.2132132132132134
   9.43943943943944
  -9.51951951951952
  -4.794794794794795
   7.137137137137137
   1.5515515515515514
  -7.757757757757758
   9.7997997997998
  -1.6116116116116117
  -9.83983983983984
   4.614614614614615
   8.91891891891892
  -5.7157157157157155
   2.3723723723723724
  -9.11911911911912
   7.757757757757758
  -3.873873873873874
   6.416416416416417
  -8.218218218218219
   9.91991991991992
  -0.8108108108108109
  -9.93993993993994
   3.973973973973974
  -7.137137137137137
   9.1991991991992
  -2.3523523523523524
   0.8108108108108109
  -9.67967967967968
   9.63963963963964
   5.235235235235235
  -5.275275275275275
   8.078078078078079

julia&gt; d = ⏃(sin, ζ, 1, 0, 1)
40-element Array{Float64,1}:
 -0.5440211108893093
 -0.05440211108893093
  0.00010554419095304635
  0.00042707706157334835
  0.00017816519362596795
 -0.00015774261733182256
 -3.046393737965622e-6
 -1.7726427136510242e-6
 -1.2091185654301347e-7
  8.298167162094031e-8
  1.623156704750302e-9
 -2.1182984780033414e-9
  3.072198477098241e-11
  2.690974958064657e-11
  7.708729505182354e-13
 -1.385345395017015e-13
  2.081712029555509e-15
  6.103669805230243e-16
  4.2232933731665444e-18
 -2.098152059762693e-18
  7.153277579328475e-21
  6.390881616124369e-21
  7.322223484376659e-23
 -1.3419887223602703e-23
 -4.050939196813086e-26
  2.4794777140850798e-26
  1.268544482329477e-28
 -3.581342740292682e-29
  2.7876085130074983e-31
  4.786776652095869e-32
  8.943705105911237e-36
 -5.432439158165548e-35
  9.88206793819289e-38
  5.559232062626121e-38
 -1.2016071877913981e-41
 -4.710497689585078e-41
  7.660823607389171e-45
  3.728816926131357e-44
 -4.378275580359998e-48
 -2.577149389756008e-47

julia&gt; np = NewtonPolynomial(ζ, d);</code></pre><p>Behind the scenes, <a href="#MatrixPolynomials.taylor_series"><code>MatrixPolynomials.taylor_series</code></a> is used to generate the Taylor expansion of <span>$\sin(x)$</span>, and when an approximation of <span>$\sin(\tau \mat{Z})$</span>, the full divided difference <span>$\sin(\mat{Z})$</span> table is recovered using <a href="#MatrixPolynomials.propagate_div_diff"><code>MatrixPolynomials.propagate_div_diff</code></a>.</p><p><img src="../figures/div_differences_sine.svg" alt="Reconstruction of sine using divided differences"/></p><h2><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.⏃" href="#MatrixPolynomials.⏃"><code>MatrixPolynomials.⏃</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">⏃(f, ζ, args...)</code></pre><p>Compute the divided differences of <code>f</code> at <code>ζ</code>, using a method that is optimized for the function <code>f</code>, if one is available, otherwise fallback to <a href="#MatrixPolynomials.ts_div_diff_table"><code>MatrixPolynomials.ts_div_diff_table</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/divided_differences.jl#LL54-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.std_div_diff" href="#MatrixPolynomials.std_div_diff"><code>MatrixPolynomials.std_div_diff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">std_div_diff(f, ζ, h, c, γ)</code></pre><p>Compute the divided differences of <code>f</code> at <code>h*(c .+ γ*ζ)</code>, where <code>ζ</code> is a vector of (possibly complex) interpolation points, using the standard recursion formula.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/divided_differences.jl#LL1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.ts_div_diff_table" href="#MatrixPolynomials.ts_div_diff_table"><code>MatrixPolynomials.ts_div_diff_table</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ts_div_diff_table(f, ζ, h, c, γ; kwargs...)</code></pre><p>Compute the divided differences of <code>f</code> at <code>h*(c .+ γ*ζ)</code>, where <code>ζ</code> is a vector of (possibly complex) interpolation points, by forming the full divided differences table using the Taylor series of <code>f(H)</code> (computed using <a href="#MatrixPolynomials.taylor_series"><code>taylor_series</code></a>). If there is a scaling relationship available for <code>f</code>, the Taylor series of <code>f(τ*H)</code> is computed instead, and the full solution is recovered using <a href="#MatrixPolynomials.propagate_div_diff"><code>propagate_div_diff</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/divided_differences.jl#LL20-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.φₖ_div_diff_basis_change" href="#MatrixPolynomials.φₖ_div_diff_basis_change"><code>MatrixPolynomials.φₖ_div_diff_basis_change</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">φₖ_div_diff_basis_change(k, ζ[; θ=3.5, s=1])</code></pre><p>Specialized interface to <a href="#MatrixPolynomials.div_diff_table_basis_change"><code>div_diff_table_basis_change</code></a> for the <code>φₖ</code> functions. <code>θ</code> is the desired radius of convergence of the Taylor series of <code>φₖ</code>, and <code>s</code> is the scaling-and-squaring parameter, which if set to zero, will be calculated to fulfill <code>θ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/divided_differences.jl#LL131-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.div_diff_table_basis_change" href="#MatrixPolynomials.div_diff_table_basis_change"><code>MatrixPolynomials.div_diff_table_basis_change</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">div_diff_table_basis_change(f, ζ[; kwargs...])</code></pre><p>Construct the table of divided differences of <code>f</code> at the interpolation points <code>ζ</code>, based on the algorithm on page 26 of</p><ul><li>Zivcovich, F. (2019). Fast and accurate computation of divided differences for analytic functions, with an application to the exponential function. Dolomites Research Notes on Approximation, 12(1), 28–42.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/divided_differences.jl#LL96-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.min_degree" href="#MatrixPolynomials.min_degree"><code>MatrixPolynomials.min_degree</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">min_degree(::typeof(exp), θ)</code></pre><p>Minimum degree of Taylor polynomial to represent <code>exp</code> to machine precision, within a circle of radius <code>θ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/divided_differences.jl#LL72-L77">source</a></section><h3><a class="nav-anchor" id="Taylor-series-1" href="#Taylor-series-1">Taylor series</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.TaylorSeries" href="#MatrixPolynomials.TaylorSeries"><code>MatrixPolynomials.TaylorSeries</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TaylorSeries(d, c)</code></pre><p>Represents the Taylor series of a function as</p><div>\[f(x) = \sum_{k=0}^\infty c_k x^{d_k},\]</div><p>where <code>dₖ = d(k)</code> and <code>cₖ = c(k)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/taylor_series.jl#LL1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.taylor_series" href="#MatrixPolynomials.taylor_series"><code>MatrixPolynomials.taylor_series</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">taylor_series(::typeof(exp))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>exp(x) = ∑ₖ x^(k) 1 / Γ(k + 1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(exp)

1 + x + 0.5x^2 + 0.16666666666666666x^3 + ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/taylor_series.jl#LL94-L105">source</a><div><div><pre><code class="language-none">taylor_series(::typeof(sin))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>sin(x) = ∑ₖ x^(2k + 1) (-1) ^ k / Γ(2k + 2)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(sin)

x - 0.16666666666666666x^3 + 0.008333333333333333x^5 - 0.0001984126984126984x^7 + ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/taylor_series.jl#LL94-L105">source</a><div><div><pre><code class="language-none">taylor_series(::typeof(cos))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>cos(x) = ∑ₖ x^(2k) (-1) ^ k / Γ(2k + 1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(cos)

1 - 0.5x^2 + 0.041666666666666664x^4 - 0.001388888888888889x^6 + ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/taylor_series.jl#LL94-L105">source</a><div><div><pre><code class="language-none">taylor_series(::typeof(sinh))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>sinh(x) = ∑ₖ x^(2k + 1) 1 / Γ(2k + 2)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(sinh)

x + 0.16666666666666666x^3 + 0.008333333333333333x^5 + 0.0001984126984126984x^7 + ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/taylor_series.jl#LL94-L105">source</a><div><div><pre><code class="language-none">taylor_series(::typeof(cosh))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>cosh(x) = ∑ₖ x^(2k) 1 / Γ(2k + 1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(cosh)

1 + 0.5x^2 + 0.041666666666666664x^4 + 0.001388888888888889x^6 + ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/taylor_series.jl#LL94-L105">source</a><div><div><pre><code class="language-none">taylor_series(::typeof(φ₁))</code></pre><p>Generates the <a href="#MatrixPolynomials.TaylorSeries"><code>TaylorSeries</code></a> of <code>φ₁(x) = ∑ₖ x^(k) 1 / Γ(k + 2)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; taylor_series(φ₁)

1 + 0.5x + 0.16666666666666666x^2 + 0.041666666666666664x^3 + ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/taylor_series.jl#LL94-L105">source</a><div><div><pre><code class="language-none">taylor_series(::Type{T}, ::typeof(exp), n; s=1, θ=3.5) where T</code></pre><p>Compute the Taylor series of <code>exp(z/s)</code>, with <code>n</code> terms, or as many terms as required to achieve convergence within a circle of radius <code>θ</code>, whichever is largest.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/divided_differences.jl#LL84-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.closure" href="#MatrixPolynomials.closure"><code>MatrixPolynomials.closure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">closure(x::Number)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/matrix_closures.jl#LL1-L5">source</a><div><div><pre><code class="language-none">closure(x::Matrix)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>Matrix</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/matrix_closures.jl#LL15-L19">source</a><div><div><pre><code class="language-none">closure(x::Diagonal)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>Diagonal</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/matrix_closures.jl#LL15-L19">source</a><div><div><pre><code class="language-none">closure(x::LowerTriangular)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>LowerTriangular</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/matrix_closures.jl#LL15-L19">source</a><div><div><pre><code class="language-none">closure(x::UpperTriangular)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>UpperTriangular</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/matrix_closures.jl#LL15-L19">source</a><div><div><pre><code class="language-none">closure(x::Bidiagonal)</code></pre><p>Generates the closure type of <code>xⁿ</code> as <code>n → ∞</code>, i.e. a <code>UpperTriangular</code> or <code>LowerTriangular</code>, depending on <code>x.uplo</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/matrix_closures.jl#LL29-L34">source</a></section><h3><a class="nav-anchor" id="Scaling-1" href="#Scaling-1">Scaling</a></h3><p>For the computation of <span>$\exp(A)$</span>, a common approach when <span>$|A|$</span> is large is to compute <span>$[\exp(A/s)]^s$</span> instead. This is known as <em>scaling and squaring</em>, if <span>$s$</span> is selected to be a power-of-two. Similar relationships can be found for other functions and are implemented for some using <a href="#MatrixPolynomials.propagate_div_diff"><code>MatrixPolynomials.propagate_div_diff</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.propagate_div_diff" href="#MatrixPolynomials.propagate_div_diff"><code>MatrixPolynomials.propagate_div_diff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">propagate_div_diff(::typeof(exp), expτH, J, args...)</code></pre><p>Find the divided differences of <code>exp</code> by utilizing that <span>$\exp(a+b)=\exp(a)\exp(b)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/propagate_divided_differences.jl#LL22-L27">source</a><div><div><pre><code class="language-none">propagate_div_diff(::typeof(φ₁), φ₁H, J, H, τ)</code></pre><p>Find the divided differences of <code>φ₁</code> by solving the ODE</p><div>\[\dot{\vec{y}}(t) = \mat{H} \vec{y}(t) + \vec{e}_1, \quad \vec{y}(0) = 0,\]</div><p>by iterating</p><div>\[\vec{y}_{j+1} = \vec{y}_j + \tau\varphi_1(\tau\mat{H})(\mat{H}\vec{y}_j + \vec{e}_1),
\quad j=0,...,J-1.\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/propagate_divided_differences.jl#LL36-L48">source</a><div><div><pre><code class="language-none">propagate_div_diff(::typeof(sin), sinH, J, H, τ)</code></pre><p>Find the divided differences of <code>sin</code>; see <a href="#MatrixPolynomials.propagate_div_diff_sin_cos"><code>propagate_div_diff_sin_cos</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/propagate_divided_differences.jl#LL87-L92">source</a><div><div><pre><code class="language-none">propagate_div_diff(::typeof(cos), cosH, J, H, τ)</code></pre><p>Find the divided differences of <code>cos</code>; see <a href="#MatrixPolynomials.propagate_div_diff_sin_cos"><code>propagate_div_diff_sin_cos</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/propagate_divided_differences.jl#LL98-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixPolynomials.propagate_div_diff_sin_cos" href="#MatrixPolynomials.propagate_div_diff_sin_cos"><code>MatrixPolynomials.propagate_div_diff_sin_cos</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">propagate_div_diff_sin_cos(sinH, cosH, J)</code></pre><p>Find the divided differences tables of <code>sin</code> and <code>cos</code> simultaneously, by utilizing the double-angle formulas</p><div>\[\sin2\theta = 2\sin\theta\cos\theta, \quad
\cos2\theta = 1 - \sin^2\theta,\]</div><p>recursively, doubling the angle at each iteration until the desired angle is achieved.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jagot/MatrixPolynomials.jl/blob/e58dd21f1f1da4f1d01020389bff492418350887/src/propagate_divided_differences.jl#LL61-L72">source</a></section><h2><a class="nav-anchor" id="Bibliography-1" href="#Bibliography-1">Bibliography</a></h2><ul><li><p>Caliari, M. (2007). Accurate evaluation of divided differences for polynomial interpolation of exponential propagators. Computing, 80(2), 189–201. <a href="http://dx.doi.org/10.1007/s00607-007-0227-1">DOI: 10.1007/s00607-007-0227-1</a></p></li><li><p>Kandolf, P., Ostermann, A., &amp; Rainer, S. (2014). A residual based error estimate for leja interpolation of matrix functions. Linear Algebra and its Applications, 456(nil), 157–173. <a href="http://dx.doi.org/10.1016/j.laa.2014.04.023">DOI: 10.1016/j.laa.2014.04.023</a></p></li><li><p>McCurdy, A. C., Ng, K. C., &amp; Parlett, B. N. (1984). Accurate computation of divided differences of the exponential function. Mathematics of Computation, 43(168), 501–501. <a href="http://dx.doi.org/10.1090/s0025-5718-1984-0758198-0">DOI: 10.1090/s0025-5718-1984-0758198-0</a></p></li><li><p>Opitz, G. (1964). Steigungsmatrizen. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift für Angewandte Mathematik und Mechanik, 44(S1), <a href="http://dx.doi.org/10.1002/zamm.19640441321">DOI: 10.1002/zamm.19640441321</a></p></li><li><p>Zivcovich, F. (2019). Fast and accurate computation of divided differences for analytic functions, with an application to the exponential function. Dolomites Research Notes on Approximation, 12(1), 28–42. <a href="https://drna.padovauniversitypress.it/system/files/papers/Zivcovich_2019_FAC.pdf">PDF: Zivcovich<em>2019</em>FAC.pdf</a></p></li></ul><footer><hr/><a class="previous" href="../phi_functions/"><span class="direction">Previous</span><span class="title">φₖ functions</span></a><a class="next" href="../newton_polynomials/"><span class="direction">Next</span><span class="title">Newton polynomials</span></a></footer></article></body></html>
